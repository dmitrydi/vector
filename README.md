# Вектор
Шаблонный класс-контейнер Vector, обеспеивающий хранение данных в непрерывном блоке памяти  

__template <typename T\>  	
class Vector;__

# Установка

\#include "vector.h"

### Требования
Поддержка компиллятором стандарта C++17  

# Функции - члены класса

Функция        | Описание
---------------|-------------------
[(конструктор)](#constructor)  | создает вектор
[(деструктор)](#destructor)  | уничтожает вектор
__Операторы присваивания__
[operator=(const Vector& other)](#copy)| оператор копирующего присваивания
[operator=(Vector&& other)](#copy)| оператор перемещающего присваивания
__Размер и ёмкость контейнера__
[Size]()| возвращает размер вектора
[Capacity]()| возвращает ёмкость вектора
__Изменение размеров и ёмкости вектора__
[Resize](#resize)| изменяет размер вектора
[Reserve](#reserve)| изменяет ёмкость вектора
__Доступ к элементам контейнера__
[operator[]](#brackets)|возвращает ссылку на элементу вектора по индексу
__Итераторы__
[begin](#begin) | возвращает указатель на начало вектора
[end](#end) | возвращает указатель на элемент за концом вектора
[cbegin](#cbegin) | возвращает константный указатель на начало вектора
[cend](#cend) | возвращает константный указатель на элемент за концом вектора
__Добавление и удаление элементов__
[PushBack](#push_back)| добавляет элемент в конец вектора
[PopBack](#pop_back)| удаляет элемент из конца вектора
[EmplaceBack](#emplace_back)| добавляет элемент в конец вектора, конструируя его на месте
[Insert](#insert)| вставляет элемент перед указателем
[Emplace](#emplace)| вставляет элемент перед указателем, создавая его на месте
[Erase](#erase)| уничтожает элемент по указателю


### Конструктор<a name = constructor></a>
Класс предоставляет следующие виды конструкторов:

	// конструктор по умолчанию
	Vector();

	// конструктор вектора длины n
	Vector(size_t n);

	// конструктор копирования
	Vector(const Vector& other);

	// конструктор перемещения
	Vector(Vector&& other) noexcept;

#### Сложность
Линейная по размеру контейнера.

### Деструктор<a name = destructor></a>
Уничтожает вектор и освобождает выделенную под него память. Если в векторе хранятся указатели на другие объекты, то разрушения объетков по указателям не происходит.

#### Сложность
Линейная по размеру контейнера.

### Vector <T\>::operator=<a name = copy></a>

	Vector& operator=(const Vector& other);

Заменяет содержимое вектора на копию содержимого __other__.

	Vector& operator=(Vector&& other) noexcept;

Заменяет содержимое вектора содержимым __other__, используя семантику перемещения. Функция не выбрасывает исключений.

#### Возвращаемое значение
Ссылка на текущий объект.

#### Сложность
Линейная по *Size() + other.Size()*.

### Vector<T\>::Size<a name = size></a>
	size_t Size() const noexcept;
Возвращает текущее количество элементов в контейнере.

#### Сложность
Константная.

### Vector<T\>::Capacity<a name = capacity></a>
	size_t Capacity() const noexcept;
Возвращает текущую ёмкость контейнера - количество зарезервированных ячеек под хранение элементов. 

#### Сложность
Константная.

### Vector<T\>::Resize<a name = resize></a>
	void Resize(size_t n);
Изменяет размер контейнера так, чтобы он содержал *n* элементов:

 * Если *n* меньше, чем текущий размер вектора, то последние *[Size()](#size)-n* элементов уничтожаются
 * Если *n > [Capacity()](#capacity)*, то происходит реаллокация данных.
 * Если *n > [Size()](#size)*, то последние *n - [Size()](#size)* элементов заполняется сконструированными по умолчанию объектами типа *T*
 
#### Сложность
Линейная.

### Vector<T\>::Reserve<a name = reserve></a>
	void Reserve(size_t n);
Увеличивает ёмкость вектора, так что она становится больше или равной *n*. Если *n > [Capacity()](#capacity)*, то происходит выделение нового участка памяти, в противном случае функция не делает ничего.

Reserve() не меняет текущий размер вектора (*[Size()](#size)*).

#### Сложность
Линейная.

### Vector<T\>::operator[]<a name = brackets></a>
	const T& operator[](size_t i) const;
Возвращает константную ссылку на элемент с индексом __i__. Попытка обращения к элементу с индексом больше или равным *size* вызывает неопределенное поведение.

	T& operator[](size_t i);
Возвращает неконстантную ссылку на элемент с индексом __i__. Попытка обращения к элементу с индексом больше или равным *size* вызывает неопределенное поведение.

#### Сложность
Константная.

### Vector<T\>::begin<a name = begin></a>
	T* begin() noexcept;
	const T* begin() const noexcept;
Возвращает указатель на первый элемент вектора.

#### Сложность
Константная.

### Vector<T\>::end<a name = end></a>
	T* end() noexcept;
	const T* end() const noexcept;
Возвращает указатель за последний элемент вектора.

#### Сложность
Константная.

### Vector<T\>::cbegin<a name = cbegin></a>
	const T* cbegin() const noexcept;
Возвращает константный указатель на первый элемент вектора.

#### Сложность
Константная.

### Vector<T\>::cend<a name = cend></a>
	const T* cend() const noexcept;
Возвращает константный указатель за последний элемент вектора.

#### Сложность
Константная.

### Vector<T\>::PushBack<a name = push_back></a>
	void PushBack(const T& elem);
Добавляет новый элемент в конец вектора. При этом происходит копирование элемента *elem*.

	void PushBack(T&& elem);
Добавляет новый элемент в конец вектора. При этом происходит перемещение элемента *elem*.

В результате выполнения функции размер вектора увеличивается на единицу. При этом, если до выполнения функции *[Size()](#size) == [Capacity()](#capacity)*, то происходит выделение нового участка памяти под хранение вектора с последующим перемещением существующих элементов в него.

#### Сложность
Амортизированная константа. В худшем случае - линейная по [Size()](#size).

### Vector<T\>::PopBack<a name = pop_back></a>
	void PopBack();

Уничтожает последний элемент из вектора, уменьшая его размер на единицу. Вызов функции от пустого контейнера приводит к неопределенному поведению.

#### Сложность
Константная.

### Vector<T\>::EmplaceBack<a name = emplace_back></a>
	template <typename ... Args>
	T& EmplaceBack(Args&&... args);

Добавляет новый элемент в конец контейнера, при этом элемент конструируется на месте - функция передает список аргументов *args* в конструктор типа *T*. Если новый размер вектора после добавления элемента превысит текущую ёмкость вектора, происходит реаллокация данных.

#### Возвращаемое значение
Ссылка на вновь созданный элемент.

#### Сложность
Амортизированная константа. В худшем случае - линейная по [Size()](#size).

### Vector<T\>::Insert<a name = insert></a>
	using iterator = T*;
	using const_iterator = const T*;

	iterator Insert(const_iterator pos, const T& elem);
	iterator Insert(const_iterator pos, T&& elem);

Вставляет элемент перед *pos*, увеличивая размер контейнера на единицу. Если новый размер вектора после добавления элемента превысит текущую ёмкость вектора, происходит реаллокация данных.

#### Возвращаемое значение
Указатель на вставленный элемент.

#### Сложность
Амортизированная константа в случае *pos == [end()](#end)*. В худшем случае - линейная по [Size()](#size).

### Vector<T\>::Emplace<a name = emplace></a>
	using iterator = T*;
	using const_iterator = const T*;

	template <typename ... Args>
	iterator Emplace(const_iterator it, Args&&... args);

Вставляет элемент перед *pos*, увеличивая размер контейнера на единицу. При этом элемент конструируется на месте. Если новый размер вектора после добавления элемента превысит текущую ёмкость вектора, происходит реаллокация данных.

#### Возвращаемое значение
Указатель на вставленный элемент.

#### Сложность
Амортизированная константа в случае *pos == [end()](#end)*. В худшем случае - линейная по [Size()](#size).

### Vector<T\>::Erase<a name = erase></a>
	using iterator = T*;
	using const_iterator = const T*;

	iterator Erase(const_iterator it);

 Удаляет элемент на позиции *pos*.

#### Возвращаемое значение
Указатель на элемент, следующий за удалённым. 

#### Сложность
Линейная по [Size()](#size).
